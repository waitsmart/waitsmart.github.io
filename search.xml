<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[新电脑，github，博客]]></title>
    <url>%2F2019%2F10%2F12%2F%E7%94%B5%E8%84%91%EF%BC%8Cgithub%EF%BC%8C%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[今天又换了位置，又要带着博客搬家了。记不住命令，导致每次都要去网上搜索，于是，今天决定把整理下来。 拷贝原博客文件我直接全拷了，不要问我为什么。这个链接是告诉你不想全拷的话可以只拷哪些 安装git：从官网下载，然后安装。 打开git bash，设置用户名称和邮件地址 $git config –global user.name “username”$git confit –global user.email “username@example.com“ 引号里面是要填你自己的用户名和邮箱地址 绑定ssh key ssh-keygen -t rsa运行此命令，然后按三次回车。它就会在你的用户主目录下生成.ssh的文件夹，里面有id_rsa.pub和id_rsa两个文件，第一个就是我们需要的公钥，用记事本或者什么打开吧，然后复制一下里面的内容。登录GitHub，打开[Settings]-&gt;[SSH and GPG keys],然后点击[new SSH key],填上任意title，在文本框粘贴之前复制的内容。然后[Add SSH Key]。就可以啦！ 安装Node.js去官网下载安装一下 安装Hexo$ npm install hexo-cli -g安装模块把你从原来电脑拷贝的博客，粘贴到新的电脑，然后打开这个文件夹。右键git bash，然后 $ npm install关联github我是这样做的 $ git remote add origin https://github.com/username/库名称但是有几个问题： 这个如果报了这个错误：fatal: remote origin already exists.（报错远程起源已经存在。）就输入 先输入 git remote rm origin再输入 git remote add origin**如果报了这个错误Error: Spawn failed你可以 先把git加入系统环境变量；再将博客目录里的.git文件夹删除命令步骤：hexo cleanhexo ghexo d我只用了hexo clean，就好了。仅供参考 还有之后会有一个问题你在弹窗中输入用户名和密码后，git的命令窗过会会显示：Username for “https://github.com&quot;: 第一次遇到的时候，我直接按了enter，然后gg了。后来在网上看了一些，不太喜欢。然后我就输入了github的username，在弹窗中输入密码，就可以了。 最后就是部署了hexo ghexo d这样子应该就可以了。反正我好了，有什么问题可以留言互相交流一下，就酱紫吧 哦对了有一个hexo的工具很有用，叫做hexo-admin npm install –save hexo-adminhexo server -dopen http://localhost:4000/admin/这个可以在在你开了本地服务后，在浏览器中写markdown文档，右边还可以对照，对我这种不熟练的人来说，真是太有帮助啦！！这篇文档就是在这个东西上写的，如果你看到了这篇博客，说明搬家成功了。有缘再见~]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F10%2F12%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[JS中深拷贝与浅拷贝]]></title>
    <url>%2F2019%2F07%2F17%2F%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[拷贝也就是克隆，最关键的一点是，我们对克隆副本的修改不会影响到本体，就是一次成功的克隆。首先考虑下面代码： 12345var a = 10;var b = a;b = 20;console.log(a); //10console.log(b); //10 上面这个代码，已经实现了拷贝，因为在改变了b之后，a没有随之改变。这是因为，在js中，基础数据类型的值是直接在栈内存中存储的。当var b=a;时，是把a的值10赋值给了b，而不是把a给了b。说到基础数据类型，就不得不提到引用数据类型，这是js中的两种数据类型。对象（引用数据类型）是保存到堆内存中的，变量保存的是对象的内存地址。然后考虑下面代码： 12345678var lilei = &#123; age:22, name:&apos;lilei&apos;&#125;var lilei2 = lilei;lilei2.age = 24;console.log(lilei); console.log(lilei2); 从这个代码块，我们测试后可以得到，lilei和lilei2的age都变为了24，那么，我们该如何拷贝对象呢？ 浅拷贝首先还是这个例子： 1234var lilei = &#123; age:22, name:&apos;lilei&apos;&#125; 因为这个一个对象，所以我们可以考虑，创建一个构造函数，来遍历对象中key，然后添加他们到新的对象中。 1234567function clone(obj)&#123; var newObj = &#123;&#125;; for(var key in obj)&#123; newObj[key]=obj[key] &#125; return newObj;&#125; 然后让想要克隆的对象，调用这个构造函数，参数就是克隆本体 1234var lilei2=clone(lilei)lilei2.age = 24;console.log(lilei);console.log(lilei2); 然后，我们到控制台去查看结果。结果正如我们所料！lilei2的age被改变为24，而lilei的age还是22.但是，请再深入思考一下。。。这样真的就可以了吗？！思考ing下面考虑一下，把lilei变为更复杂的结构，内嵌对象，数组以及null。为什么要考虑null呢?因为我们要用typeof判断数据类型，而null会被判断为对象。可以尝试下面的代码： 123456789101112var lilei = nullfunction clone(obj)&#123; var newObj = &#123;&#125;; for(var key in obj)&#123; newObj[key]=obj[key] &#125; return newObj;&#125;//改变var lilei2=clone(lilei)console.log(lilei);console.log(lilei2); 会发现：null变成了{}。然后让我们考虑下面的代码： 12345678910var lilei = &#123; name:&apos;lilei&apos;, age:22, address:&#123; prov:&quot;河南&quot;, city:&quot;郑州&quot;, area:&quot;金水区&quot; &#125;, score:[100,90,80]&#125; 然后试着还是用上面的构造函数，写一写改变，看一看结果： 1234567891011121314function clone(obj)&#123; var newObj = &#123;&#125;; for(var key in obj)&#123; newObj[key]=obj[key] &#125; return newObj;&#125;//改变var lilei2=clone(lilei)lilei2.age = 24;lilei2.address.area=&quot;饮水区&quot;;lilei2.score[2]=100;console.log(lilei);console.log(lilei2); 仔细看一看哪些改变了，哪些没有改变呢？可以看到，score[2]和address里的area，lilei也跟着改变了，这里我们可以看到：这是因为，浅拷贝没有复制内嵌的对象或数组，而是复制了地址，当内容改变，引用了这个地址的都会发生改变。** 浅拷贝：如果包含内嵌的对象或数组，则不再复制副本 ** 由此引出深拷贝：** 深拷贝：如果包含内嵌的对象或数组，也复制副本 ** 那么什么方法可以实现深拷贝呢？可以改造以下构造函数。 以下是深拷贝的方法：1234567891011121314151617181920212223function clone(obj)&#123; //针对传过的是null的时候 if(obj===null)&#123; return null; &#125; //传来的是数组,通过slice返回新数组 if(&#123;&#125;.toString.call(obj)===&quot;[object Array]&quot;)&#123; var newArr=[]; newArr=obj.slice(); return newArr; &#125; //上面两种排除后，剩下是对象 var newObj=&#123;&#125;; for(var key in obj)&#123; if(typeof obj[key]!==&quot;object&quot;)&#123; //如果原对象中当前属性值是原始类型 newObj[key]=obj[key] &#125;else&#123; newObj[key]=clone(obj[key]) &#125; &#125; return newObj&#125; 好了，结束。大家可以测试一下。如果有误，或是交流，可以留言或者发邮件。再见！]]></content>
      <tags>
        <tag>深拷贝与浅拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决跨域的几种方式]]></title>
    <url>%2F2019%2F07%2F07%2F%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是跨域？为什么会有这个问题？因为浏览器同源策略：禁止跨不同源头访问资源。仅限于ajax*跨域：从一个域名下的网页，向另一个域名下的服务端发送ajax请求—受服务器同源策略限制，禁止发送** 域名不同、子级域名不同、端口号不同、协议不同、同一台及其的域名和ip之间相互访问这些都是会报错的！！##例如这些##http://www.a.com -&gt;http://www.b.comhttp://www.b.a.com -&gt; http://www.c.a.comhttp://localhost:5500 -&gt;http://localhost:3300http://localhost -&gt; https://localhosthttp://localhost -&gt; http://127.0.0.1 都是会报错的 CORS…Access-Control-Allow-Origin翻译过来就是 CORS-&gt; Cross-Origin Resource Sharing 跨域资源共享Access-Control-Allow-Origin 访问 控制 允许 来源；域 怎么解决呢？1.CORS方式 即 跨域资源访问技术是现在比较主流的解决方式，仅服务端改代码，就可跨域这里再说一下同源策略的本质：其实可以发送ajax请求，也可以正常执行服务端的程序，也可以顺利返回正确的结果。但是，浏览器经过检查数据的来源，发现和当前网页的来源不一致，所以，到手的数据不让用！怎么办呢？其实就是在服务端返回响应的响应头中伪装成指定的源头 res.send(result)res.send()是一种简写 等效于 res.writeHead()+res.write(JSON.stringify(result))+res.end 可以这样子写12345res.writeHead(200,&#123; &quot;Access-Control-Allow-Origin&quot;:&quot;http://127.0.0.1:5500&quot; &#125;);res.write(JSON.stringify(result));res.end() 这样返回的数据，就被伪装成来自于127.0.0.1:5500的，就可以访问了。也可以引入cors模块,例如 12345const cors=require(&apos;cors&apos;);server.use(cors(&#123; &apos;credentials&apos;:true, &apos;origin&apos;:&apos;http://localhost:8100&apos;&#125;)); 2.JSONP方式：JSON with padding 填充式JSONjQuery对jsonp方式跨域进行了终极的简化: 123456789$.ajax(&#123; url: type: data: dataType:&quot;jsonp&quot; success:function()&#123; ... ...&#125;&#125;) 先写这么多吧，我比较熟练的就是cors了，写的比较简单，应该是简陋吧，只是我个人学习过程中的一点收获。毕竟~~有google]]></content>
      <tags>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第二篇 说点什么好呢]]></title>
    <url>%2F2019%2F06%2F25%2F%E7%AC%AC%E4%BA%8C%E7%AF%87-%E8%AF%B4%E7%82%B9%E4%BB%80%E4%B9%88%E5%A5%BD%E5%91%A2%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[我的测试文字]]></title>
    <url>%2F2019%2F06%2F25%2F%E6%88%91%E7%9A%84%E6%B5%8B%E8%AF%95%E6%96%87%E5%AD%97%2F</url>
    <content type="text"><![CDATA[$$\begin{eqnarray}\nabla\cdot\vec{E} &amp;=&amp; \frac{\rho}{\epsilon_0} \\nabla\cdot\vec{B} &amp;=&amp; 0 \\nabla\times\vec{E} &amp;=&amp; -\frac{\partial B}{\partial t} \\nabla\times\vec{B} &amp;=&amp; \mu_0\left(\vec{J}+\epsilon_0\frac{\partial E}{\partial t} \right)\end{eqnarray}$$]]></content>
  </entry>
</search>
