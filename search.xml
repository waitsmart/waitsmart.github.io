<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JS中深拷贝与浅拷贝]]></title>
    <url>%2F2019%2F07%2F17%2F%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[拷贝也就是克隆，最关键的一点是，我们对克隆副本的修改不会影响到本体，就是一次成功的克隆。首先考虑下面代码： 12345var a = 10;var b = a;b = 20;console.log(a); //10console.log(b); //10 上面这个代码，已经实现了拷贝，因为在改变了b之后，a没有随之改变。这是因为，在js中，基础数据类型的值是直接在栈内存中存储的。当var b=a;时，是把a的值10赋值给了b，而不是把a给了b。说到基础数据类型，就不得不提到引用数据类型，这是js中的两种数据类型。对象（引用数据类型）是保存到堆内存中的，变量保存的是对象的内存地址。然后考虑下面代码： 12345678var lilei = &#123; age:22, name:&apos;lilei&apos;&#125;var lilei2 = lilei;lilei2.age = 24;console.log(lilei); console.log(lilei2); 从这个代码块，我们测试后可以得到，lilei和lilei2的age都变为了24，那么，我们该如何拷贝对象呢？ 浅拷贝首先还是这个例子： 1234var lilei = &#123; age:22, name:&apos;lilei&apos;&#125; 因为这个一个对象，所以我们可以考虑，创建一个构造函数，来遍历对象中key，然后添加他们到新的对象中。 1234567function clone(obj)&#123; var newObj = &#123;&#125;; for(var key in obj)&#123; newObj[key]=obj[key] &#125; return newObj;&#125; 然后让想要克隆的对象，调用这个构造函数，参数就是克隆本体 1234var lilei2=clone(lilei)lilei2.age = 24;console.log(lilei);console.log(lilei2); 然后，我们到控制台去查看结果。结果正如我们所料！lilei2的age被改变为24，而lilei的age还是22.但是，请再深入思考一下。。。这样真的就可以了吗？！思考ing下面考虑一下，把lilei变为更复杂的结构，内嵌对象，数组以及null。为什么要考虑null呢?因为我们要用typeof判断数据类型，而null会被判断为对象。可以尝试下面的代码： 123456789101112var lilei = nullfunction clone(obj)&#123; var newObj = &#123;&#125;; for(var key in obj)&#123; newObj[key]=obj[key] &#125; return newObj;&#125;//改变var lilei2=clone(lilei)console.log(lilei);console.log(lilei2); 会发现：null变成了{}。然后让我们考虑下面的代码： 12345678910var lilei = &#123; name:&apos;lilei&apos;, age:22, address:&#123; prov:&quot;河南&quot;, city:&quot;郑州&quot;, area:&quot;金水区&quot; &#125;, score:[100,90,80]&#125; 然后试着还是用上面的构造函数，写一写改变，看一看结果： 1234567891011121314function clone(obj)&#123; var newObj = &#123;&#125;; for(var key in obj)&#123; newObj[key]=obj[key] &#125; return newObj;&#125;//改变var lilei2=clone(lilei)lilei2.age = 24;lilei2.address.area=&quot;饮水区&quot;;lilei2.score[2]=100;console.log(lilei);console.log(lilei2); 仔细看一看哪些改变了，哪些没有改变呢？可以看到，score[2]和address里的area，lilei也跟着改变了，这里我们可以看到：这是因为，浅拷贝没有复制内嵌的对象或数组，而是复制了地址，当内容改变，引用了这个地址的都会发生改变。** 浅拷贝：如果包含内嵌的对象或数组，则不再复制副本 ** 由此引出深拷贝：** 深拷贝：如果包含内嵌的对象或数组，也复制副本 ** 那么什么方法可以实现深拷贝呢？可以改造以下构造函数。 以下是深拷贝的方法：1234567891011121314151617181920212223function clone(obj)&#123; //针对传过的是null的时候 if(obj===null)&#123; return null; &#125; //传来的是数组,通过slice返回新数组 if(&#123;&#125;.toString.call(obj)===&quot;[object Array]&quot;)&#123; var newArr=[]; newArr=obj.slice(); return newArr; &#125; //上面两种排除后，剩下是对象 var newObj=&#123;&#125;; for(var key in obj)&#123; if(typeof obj[key]!==&quot;object&quot;)&#123; //如果原对象中当前属性值是原始类型 newObj[key]=obj[key] &#125;else&#123; newObj[key]=clone(obj[key]) &#125; &#125; return newObj&#125; 好了，结束。大家可以测试一下。如果有误，或是交流，可以留言或者发邮件。再见！]]></content>
      <tags>
        <tag>深拷贝与浅拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决跨域的几种方式]]></title>
    <url>%2F2019%2F07%2F07%2F%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是跨域？为什么会有这个问题？因为浏览器同源策略：禁止跨不同源头访问资源。仅限于ajax*跨域：从一个域名下的网页，向另一个域名下的服务端发送ajax请求—受服务器同源策略限制，禁止发送** 域名不同、子级域名不同、端口号不同、协议不同、同一台及其的域名和ip之间相互访问这些都是会报错的！！##例如这些##http://www.a.com -&gt;http://www.b.comhttp://www.b.a.com -&gt; http://www.c.a.comhttp://localhost:5500 -&gt;http://localhost:3300http://localhost -&gt; https://localhosthttp://localhost -&gt; http://127.0.0.1 都是会报错的 CORS…Access-Control-Allow-Origin翻译过来就是 CORS-&gt; Cross-Origin Resource Sharing 跨域资源共享Access-Control-Allow-Origin 访问 控制 允许 来源；域 怎么解决呢？1.CORS方式 即 跨域资源访问技术是现在比较主流的解决方式，仅服务端改代码，就可跨域这里再说一下同源策略的本质：其实可以发送ajax请求，也可以正常执行服务端的程序，也可以顺利返回正确的结果。但是，浏览器经过检查数据的来源，发现和当前网页的来源不一致，所以，到手的数据不让用！怎么办呢？其实就是在服务端返回响应的响应头中伪装成指定的源头 res.send(result)res.send()是一种简写 等效于 res.writeHead()+res.write(JSON.stringify(result))+res.end 可以这样子写12345res.writeHead(200,&#123; &quot;Access-Control-Allow-Origin&quot;:&quot;http://127.0.0.1:5500&quot; &#125;);res.write(JSON.stringify(result));res.end() 这样返回的数据，就被伪装成来自于127.0.0.1:5500的，就可以访问了。也可以引入cors模块,例如 12345const cors=require(&apos;cors&apos;);server.use(cors(&#123; &apos;credentials&apos;:true, &apos;origin&apos;:&apos;http://localhost:8100&apos;&#125;)); 2.JSONP方式：JSON with padding 填充式JSONjQuery对jsonp方式跨域进行了终极的简化: 123456789$.ajax(&#123; url: type: data: dataType:&quot;jsonp&quot; success:function()&#123; ... ...&#125;&#125;) 先写这么多吧，我比较熟练的就是cors了，写的比较简单，应该是简陋吧，只是我个人学习过程中的一点收获。毕竟~~有google]]></content>
      <tags>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第二篇 说点什么好呢]]></title>
    <url>%2F2019%2F06%2F25%2F%E7%AC%AC%E4%BA%8C%E7%AF%87-%E8%AF%B4%E7%82%B9%E4%BB%80%E4%B9%88%E5%A5%BD%E5%91%A2%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[我的测试文字]]></title>
    <url>%2F2019%2F06%2F25%2F%E6%88%91%E7%9A%84%E6%B5%8B%E8%AF%95%E6%96%87%E5%AD%97%2F</url>
    <content type="text"><![CDATA[$$\begin{eqnarray}\nabla\cdot\vec{E} &amp;=&amp; \frac{\rho}{\epsilon_0} \\nabla\cdot\vec{B} &amp;=&amp; 0 \\nabla\times\vec{E} &amp;=&amp; -\frac{\partial B}{\partial t} \\nabla\times\vec{B} &amp;=&amp; \mu_0\left(\vec{J}+\epsilon_0\frac{\partial E}{\partial t} \right)\end{eqnarray}$$]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F06%2F25%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
